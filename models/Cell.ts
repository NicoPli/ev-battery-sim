export class Cell {
  private _temperature: number = 25; // Ambient temperature in Celsius
  private _stateOfCharge: number = 0.1; // 10% initial charge
  private _capacity: number = 10; // Ah
  private _internalResistance: number = 0.01; // Ohms
  private _maxVoltage: number = 4.2; // V
  private _minVoltage: number = 3.2; // V
  private _nominalVoltage: number = 3.7; // V
  private _randomFactor: number = 0.95 + Math.random() * 0.1; // 0.95-1.05 random variation
  private _chargingEfficiency: number = 1.0; // Base charging efficiency
  private _charge: number = 0; // Internal charge storage

  constructor(initialSoc: number = 0.1, capacity: number = 10) {
    // Add randomness to initial state of charge (±5%)
    this._stateOfCharge = initialSoc * (0.95 + Math.random() * 0.1);
    
    // Add randomness to cell capacity (±10%)
    this._capacity = capacity * (0.9 + Math.random() * 0.2);
    
    // Initialize charge based on state of charge
    this._charge = this._stateOfCharge * this._capacity;
    
    // Add randomness to internal resistance (±20%)
    this._internalResistance = this._internalResistance * (0.8 + Math.random() * 0.4);
  }

  get temperature(): number {
    return this._temperature;
  }

  set temperature(value: number) {
    this._temperature = value;
  }

  get stateOfCharge(): number {
    return this._stateOfCharge;
  }

  set stateOfCharge(value: number) {
    this._stateOfCharge = Math.max(0, Math.min(1, value));
  }

  get voltage(): number {
    // More realistic non-linear voltage curve
    if (this._stateOfCharge < 0.1) {
      // Steeper curve at low SoC
      return this._minVoltage + (this._stateOfCharge / 0.1) * 0.2;
    } else if (this._stateOfCharge > 0.9) {
      // Steeper curve at high SoC - ensure cells approach max voltage
      const baseVoltage = this._minVoltage + 0.8; // 4.0V at 90% SoC
      // Ensure we reach exactly 4.2V at 100% SoC
      const remainingRange = this._maxVoltage - baseVoltage; // 0.2V
      const normalizedSoc = (this._stateOfCharge - 0.9) / 0.1; // 0-1 range for 90-100% SoC
      // Use a curve that approaches 4.2V more quickly
      return baseVoltage + remainingRange * Math.pow(normalizedSoc, 0.5);
    } else {
      // Linear in the middle range
      return this._minVoltage + 0.2 + ((this._stateOfCharge - 0.1) / 0.8) * 0.6;
    }
  }

  get capacity(): number {
    return this._capacity;
  }

  get randomFactor(): number {
    return this._randomFactor;
  }

  updateCharge(current: number, deltaTimeHours: number): void {
    // Each cell has a significantly different charging efficiency
    // This creates more pronounced imbalance over time
    const chargingEfficiency = this._chargingEfficiency * (0.7 + Math.random() * 0.6); // 70-130% of base efficiency
    
    // Calculate charge added (in Ah)
    const chargeAdded = current * deltaTimeHours * chargingEfficiency;
    
    // Calculate new charge level
    const newCharge = this._charge + chargeAdded;
    
    // Limit to capacity
    this._charge = Math.min(newCharge, this._capacity);
    
    // Update state of charge
    this._stateOfCharge = this._charge / this._capacity;
    
    // Ensure SoC doesn't exceed 1.0 (100%)
    if (this._stateOfCharge > 1.0) {
      this._stateOfCharge = 1.0;
      this._charge = this._capacity;
    }
  }

  updateTemperature(current: number, deltaTimeHours: number, cooling: number): void {
    // Only generate heat if there's current flowing
    if (current > 0.1) {
      // Calculate heat generated by charging (I²R)
      const effectiveResistance = this._internalResistance * 15; // Reduced from 25x to 15x
      
      // More reasonable current effect
      const heatGenerated = Math.pow(current, 2) * effectiveResistance * deltaTimeHours;
      
      // Apply random factor to heating with moderate variation
      const effectiveHeat = heatGenerated * (this._randomFactor + 0.2);
      
      // Temperature rise (simplified model)
      const tempRise = effectiveHeat * 0.7; // Reduced from 1.0 to 0.7
      
      // Update temperature with heat from charging
      this._temperature = this._temperature + tempRise;
    }
    
    // Ambient temperature effect (always happens)
    const ambientDiff = 25 - this._temperature;
    const ambientEffect = 0.05 * ambientDiff * deltaTimeHours;
    
    // Cooling effect (proportional to temperature difference from ambient)
    const coolingEffect = cooling * 0.3 * (this._temperature - 25) * deltaTimeHours;
    
    // Apply ambient and cooling effects
    this._temperature = this._temperature + ambientEffect + (this._temperature > 25 ? coolingEffect : 0);
    
    // Add occasional small random variations
    if (Math.random() < 0.005) { // 0.5% chance per update
      this._temperature += (Math.random() - 0.5) * 0.5; // +/- 0.25 degrees randomly
    }
  }

  reset(): void {
    this._temperature = 25;
    this._stateOfCharge = 0.1;
  }

  private updateVoltage(): void {
    // This method is called after SoC changes to update internal state
    // No need to do anything as voltage is calculated dynamically from SoC
  }
} 