export class Cell {
  private _temperature: number = 25; // Ambient temperature in Celsius
  private _stateOfCharge: number = 0.1; // 10% initial charge
  private _capacity: number = 10; // Ah
  private _internalResistance: number = 0.01; // Ohms
  private _maxVoltage: number = 4.2; // V
  private _minVoltage: number = 3.2; // V
  private _nominalVoltage: number = 3.7; // V
  private _randomFactor: number = 0.95 + Math.random() * 0.1; // 0.95-1.05 random variation

  constructor(initialSoc: number = 0.1, capacity: number = 10) {
    this._stateOfCharge = initialSoc;
    this._capacity = capacity;
  }

  get temperature(): number {
    return this._temperature;
  }

  set temperature(value: number) {
    this._temperature = value;
  }

  get stateOfCharge(): number {
    return this._stateOfCharge;
  }

  set stateOfCharge(value: number) {
    this._stateOfCharge = Math.max(0, Math.min(1, value));
  }

  get voltage(): number {
    // More realistic non-linear voltage curve
    if (this._stateOfCharge < 0.1) {
      // Steeper curve at low SoC
      return this._minVoltage + (this._stateOfCharge / 0.1) * 0.2;
    } else if (this._stateOfCharge > 0.9) {
      // Steeper curve at high SoC
      const baseVoltage = this._minVoltage + 0.8;
      return baseVoltage + ((this._stateOfCharge - 0.9) / 0.1) * 0.2;
    } else {
      // Linear in the middle range
      return this._minVoltage + 0.2 + ((this._stateOfCharge - 0.1) / 0.8) * 0.6;
    }
  }

  get capacity(): number {
    return this._capacity;
  }

  get randomFactor(): number {
    return this._randomFactor;
  }

  updateCharge(current: number, deltaTimeHours: number): void {
    // Apply random factor to charging rate
    const effectiveCurrent = current * this._randomFactor;
    
    // Calculate change in SoC
    const deltaSoc = (effectiveCurrent * deltaTimeHours) / this._capacity;
    
    // Update SoC
    this._stateOfCharge = Math.min(1, this._stateOfCharge + deltaSoc);
  }

  updateTemperature(current: number, deltaTimeHours: number, cooling: number): void {
    // Only generate heat if there's current flowing
    if (current > 0.1) {
      // Calculate heat generated by charging (IÂ²R)
      const effectiveResistance = this._internalResistance * 15; // Reduced from 25x to 15x
      
      // More reasonable current effect
      const heatGenerated = Math.pow(current, 2) * effectiveResistance * deltaTimeHours;
      
      // Apply random factor to heating with moderate variation
      const effectiveHeat = heatGenerated * (this._randomFactor + 0.2);
      
      // Temperature rise (simplified model)
      const tempRise = effectiveHeat * 0.7; // Reduced from 1.0 to 0.7
      
      // Update temperature with heat from charging
      this._temperature = this._temperature + tempRise;
    }
    
    // Ambient temperature effect (always happens)
    const ambientDiff = 25 - this._temperature;
    const ambientEffect = 0.05 * ambientDiff * deltaTimeHours;
    
    // Cooling effect (proportional to temperature difference from ambient)
    const coolingEffect = cooling * 0.3 * (this._temperature - 25) * deltaTimeHours;
    
    // Apply ambient and cooling effects
    this._temperature = this._temperature + ambientEffect + (this._temperature > 25 ? coolingEffect : 0);
    
    // Add occasional small random variations
    if (Math.random() < 0.005) { // 0.5% chance per update
      this._temperature += (Math.random() - 0.5) * 0.5; // +/- 0.25 degrees randomly
    }
  }

  reset(): void {
    this._temperature = 25;
    this._stateOfCharge = 0.1;
  }
} 